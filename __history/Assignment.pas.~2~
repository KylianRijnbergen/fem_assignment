unit Assignment;

interface

uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, VclTee.TeeGDIPlus, VCLTee.TeEngine,
  Vcl.ExtCtrls, VCLTee.TeeProcs, VCLTee.Chart, VCLTee.Series, Vcl.StdCtrls, math;

type
  TValueArrayX = array of double;
  TBetaStar = array of array of array of double;

procedure AssignmentA(p: double; X:TValueArrayX; var ResultArray: array of TValueArrayX);
procedure AssignmentB(p, Beta: double; X:TValueArrayX; var ResultArray: array of TValueArrayX);
procedure AssignmentC(p, beta: double; K:integer; X:TValueArrayX;
  var ResultArray: Array of TValueArrayX;
  var BetaStar: TBetaStar);

implementation

// This procedure runs when the Button "Run Assignment 1" is pressed
// Determine the expected value of X
// write result to ResultArray
procedure AssignmentA(p: double; X:TValueArrayX; var ResultArray: array of TValueArrayX);
begin
end;

function EntropicRiskMeasure(X_input:TValueArrayX; Beta, p: double):TValueArrayX; //With p the probability for an up-branch, Beta the stress unit
var
  N, i: integer;
  Xu, Xd, M: TValueArrayX;
begin
  //Initialize
  N := Length(X_input);
  setLength(Xu, N - 1);
  setLength(Xd, N - 1);
  Xu := Copy(X_input, 0, N - 1);
  Xd := Copy(X_input, 1, N);
  setLength(M, N-1);
  for i := 0 to N - 2 do
  begin // take conditional mean out of exponential to avoid numerical problems
    M[i] := p * Xu[i] + (1-p) * Xd[i];
  end;
  if Beta = 0 then //If there is no risk parameter beta then this is just the result
  begin
    Result := M;
  end
  else
  begin
    for i := 0 to N - 2 do
    begin
      Xu[i] := p * Exp(-Beta * (Xu[i] - M[i])); //A vector with the expected values for the price to go up
      Xd[i] := (1 - p) * Exp(-Beta * (Xd[i] - M[i])); //A vector with the expected values for the price to go down
      M[i] := M[i] - (Ln(Xu[i] + Xd[i])/Beta);
    end;
    Result := M;
  end;
end;

// Next procedure runs when the Button "Run Assignment 2" is pressed
// Determine the expected value of X using the Entropic Risk Measure
// write result to ResultArray
procedure AssignmentB(p, Beta: double; X:TValueArrayX; var ResultArray: array of TValueArrayX);
begin
end;

// This procedure runs when the Button "Run Assignment 3" is pressed
// Determine the expected value of X
// write result to ResultArray, BetaStar
procedure AssignmentC(p, beta: double; K:integer; X:TValueArrayX;
  var ResultArray: Array of TValueArrayX;
  var BetaStar: TBetaStar);
var
  T, tt, N, kk, kkk: integer;
  BetaSet: array of double;
  Y, Y_intermediate:array of TValueArrayX;
begin
  //Initialization, check parameters
  //1. Check that Beta >0, K > 0, X has at least two values


  //2. N := Length(X), T = N - 1
  N := Length(X);
  T := N - 1; //Where T is number of time steps
  setLength(Y_intermediate, N);

  Y_intermediate[N-1] := X;

  // If T == 1 -> Beta = Beta, result = Entropic risk measure on X
  if T = 1 then
  begin
  end;

  //Further assume T > 1

  //3. Initialize an empty set of Beta values (BetaSet[])
  // with  [0,h,2*h,...,beta], with h=beta/K, so a range of K+1 values
  setLength(BetaSet, K + 1);
  for kk := 0 to K do
  begin
    BetaSet[kk] := kk * Beta / K;
  end;

  //4. Define BetaStar -> stores optimal beta_t by index in betaset
  //betastar(k,i,j) is index optimal beta in node (i,j)
  setLength(BetaStar, K + 1);
  for kk := 0 to K do
  begin
    setLength(BetaStar[kk],T);
    for tt := 0 to T - 1 do
    begin
      setLength(BetaStar[kk, tt], T);
    end;
  end;

  //evaluate at T-1 outcome for all beta in betaset.
  //store in Y with k-th column corresponding to k-th element in betaset
  //5. For kk := 0 to K find EntropicRiskMeasure(X, BetaSet[kk], p), write outcome to array of array Yt
  // BetaStar[kk, T, i) = kk
  setLength(Y, K + 1);
  for kk := 0 to K do
  begin
    Y[kk] := EntropicRiskMeasure(X, BetaSet[kk], p);
    for tt := 0 to T - 1 do
    begin
      BetaStar[kk, T - 1, tt] := kk; //at T-1, take beta_T-1 at (k-1)-th notch
    end;
  end;
  Y_intermediate[T-1] := Y[K]; // Store intermediate results in Y_intermediate

  //6. Backward Recursion For tt := T-2 downto 0
  for tt := T - 2 downto 0 do
  begin
    //7. Determine Entropic Risk measure for k = 0, then BetaStar(0,tt,node) := 0
    for kk := 2 to K + 1 do
    begin
      for kkk := 1 to kk do
      begin
        // 8. Yk[i,kk] = EntropicRiskMeasure(New array of X values, BetaSet(kkk), p)
        // Assuming this array of array is called Yk
      end; // next kkk
          // 9. Now determine the value of k that minimized the value in Y over
          // the value of kk, so not over the nodes, but over the budgets.
          // This value of k is stored in BetaStar, the actual minimum is
          // the value that needs to be set to a new array, which represents the
          // Vector X that is used in the next iteration in the entropic risk measure
    end;  // next kk
  end;  // nex tt
  // 10. Finally, do not forget to write the results to ResultArray
end;
end.

